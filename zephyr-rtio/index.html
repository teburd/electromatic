<!DOCTYPE html>
<html lang="en" itemscope itemtype="http://schema.org/Blog">
<head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">

    <!-- Enable responsiveness on mobile devices-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

    <title> Zephyr RTIO </title>

    
        <link rel="apple-touch-icon" sizes="57x57" href="https://electromatic.us/apple-icon-57x57.png">
        <link rel="apple-touch-icon" sizes="60x60" href="https://electromatic.us/apple-icon-60x60.png">
        <link rel="apple-touch-icon" sizes="72x72" href="https://electromatic.us/apple-icon-72x72.png">
        <link rel="apple-touch-icon" sizes="76x76" href="https://electromatic.us/apple-icon-76x76.png">
        <link rel="apple-touch-icon" sizes="114x114" href="https://electromatic.us/apple-icon-114x114.png">
        <link rel="apple-touch-icon" sizes="120x120" href="https://electromatic.us/apple-icon-120x120.png">
        <link rel="apple-touch-icon" sizes="144x144" href="https://electromatic.us/apple-icon-144x144.png">
        <link rel="apple-touch-icon" sizes="152x152" href="https://electromatic.us/apple-icon-152x152.png">
        <link rel="apple-touch-icon" sizes="180x180" href="https://electromatic.us/apple-icon-180x180.png">
        <link rel="icon" href="/favicon.ico" type="image/x-icon">
        <link rel="icon" type="image/png" sizes="192x192"  href="https://electromatic.us/android-icon-192x192.png">
        <link rel="icon" type="image/png" sizes="32x32" href="https://electromatic.us/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="96x96" href="https://electromatic.us/favicon-96x96.png">
        <link rel="icon" type="image/png" sizes="16x16" href="https://electromatic.us/favicon-16x16.png">
        <link rel="manifest" href="/manifest.json">
        <meta name="msapplication-TileColor" content="#ffffff">
        <meta name="msapplication-TileImage" content="/ms-icon-144x144.png">
        <meta name="theme-color" content="#ffffff">
        <meta name="description" itemprop="about" content="">
        <meta name="keywords" itemprop="keywords" content="electromatic, Tom Burdick, electronics, firmware, zephyr">
        <meta itemprop="headline" content="Electromatic.us"/>

        

        
            <meta itemprop="copyrightYear" content="2025" />
        

        <!--  Social Media -->
        <meta property="og:title" content="Electromatic.us Zephyr RTIO ">
        <meta property="og:description" content="  A new DMA friendly IO driver layer for sampled input and output for Zephyr ">
        <meta property="og:image" content="">
        <meta property="og:url" content="https:&#x2F;&#x2F;electromatic.us&#x2F;zephyr-rtio&#x2F;">
        <meta name="twitter:card" content="summary_large_image">
        <meta property="og:site_name" content="">
        <meta name="twitter:image:alt" content="Zephyr RTIO">


        

        
    

    

    
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:400,600|Source+Code+Pro">
        <link rel="stylesheet" href="/site.css">
    
</head>
<body>
    
    <div 
     itemscope itemtype="http://schema.org/Organization">
    </div>

    <header class="header">
        <div class="container">
            <a class="title" href="https:&#x2F;&#x2F;electromatic.us">
                
                    
                    
                        <h1 >Electromatic</h1>
                    
                
            </a>
        </div>
    </header>
    <div class="container padding-header">
        
<article itemscope itemtype="http://schema.org/BlogPosting" class="post post-page">
    
        
    
    <header>
        
            <a  class="category" href="https://electromatic.us/categories/zephyr/">
                Zephyr
            </a>
        
        <h1 class="title" itemprop="headline">Zephyr RTIO</h1>
        <div class="extra">
            
                Tags:
                
                    <a href="https://electromatic.us/tags/zehpyr/">zehpyr</a>
                    
                        
                            
                                ,
                            
                        
                    
                
                    <a href="https://electromatic.us/tags/sensors/">sensors</a>
                    
                        
                            
                                and
                            
                        
                    
                
                    <a href="https://electromatic.us/tags/embedded/">embedded</a>
                    
                        
                    
                
            

            
        </div>
    </header>
    <div itemprop="articleBody" class="body">
      <h2 id="zephyr">Zephyr</h2>
<p>For the past year or so I've been working on ever more complex electronics
devices and firmware. Devices that have greater needs for performance
sensing, processing, and communicating. Specifically I have a chromatography
control system and a sport training device I've been working on.</p>
<p>Writing infinite loop state machines works well to a point. After a certain
level of complexity I'd argue its easier to reason about several state machines
that communicate. I learned that the hard way when creating a soft realtime
control system for chromatography, a story for another time.</p>
<p>An RTOS provides the means to structure a program with communicating state
machines. It does not prevent a devolvement into spaghetti, data race,
bug ridden nightmare fuel.</p>
<p>Zephyr is a fantastic RTOS, with a large test suite covering its core
functionality, soc drivers, and board support packages.</p>
<p>What it lacked however for both of the projects I've been working on was
a driver API that made sense for my use case. I need to stream compact,
potentially processed by digital filters, sampled data streams. So
sensors. Fast ones!</p>
<h2 id="the-status-quo">The Status Quo</h2>
<p>It's worth noting that the Zephyr API for sensors (current as of this
writing still) is quite simple. That's a good thing!</p>
<p>A sample from Zephyr makes it clear whats involved.</p>
<p><a href="https://github.com/zephyrproject-rtos/zephyr/blob/zephyr-v1.14.0/samples/sensor/magn_polling/src/main.c">Sensor Sample Snippet</a></p>
<pre data-lang="c" style="background-color:#2b303b;color:#c0c5ce;" class="language-c "><code class="language-c" data-lang="c"><span style="color:#b48ead;">int</span><span> ret;
</span><span style="color:#b48ead;">struct</span><span> sensor_value value_x, value_y, value_z;
</span><span>
</span><span style="color:#b48ead;">while </span><span>(</span><span style="color:#d08770;">1</span><span>) {
</span><span>    ret = </span><span style="color:#bf616a;">sensor_sample_fetch</span><span>(dev);
</span><span>    </span><span style="color:#b48ead;">if </span><span>(ret) {
</span><span>        </span><span style="color:#bf616a;">printk</span><span>(&quot;</span><span style="color:#a3be8c;">sensor_sample_fetch failed ret </span><span style="color:#d08770;">%d</span><span style="color:#96b5b4;">\n</span><span>&quot;, ret);
</span><span>        </span><span style="color:#b48ead;">return</span><span>;
</span><span>    }
</span><span>
</span><span>    ret = </span><span style="color:#bf616a;">sensor_channel_get</span><span>(dev, SENSOR_CHAN_MAGN_X, &amp;value_x);
</span><span>    ret = </span><span style="color:#bf616a;">sensor_channel_get</span><span>(dev, SENSOR_CHAN_MAGN_Y, &amp;value_y);
</span><span>    ret = </span><span style="color:#bf616a;">sensor_channel_get</span><span>(dev, SENSOR_CHAN_MAGN_Z, &amp;value_z);
</span><span>    </span><span style="color:#96b5b4;">printf</span><span>(&quot;</span><span style="color:#a3be8c;">( x y z ) = ( </span><span style="color:#d08770;">%f  %f  %f</span><span style="color:#a3be8c;"> )</span><span style="color:#96b5b4;">\n</span><span>&quot;,
</span><span>            </span><span style="color:#bf616a;">sensor_value_to_double</span><span>(&amp;value_x),
</span><span>            </span><span style="color:#bf616a;">sensor_value_to_double</span><span>(&amp;value_y),
</span><span>            </span><span style="color:#bf616a;">sensor_value_to_double</span><span>(&amp;value_z));
</span><span>
</span><span>    </span><span style="color:#bf616a;">k_sleep</span><span>(</span><span style="color:#d08770;">500</span><span>);
</span><span>}
</span></code></pre>
<p>This API is convienent and straightforward.</p>
<p>This API got me quite far with <em>most</em> what I was trying to do. In fact
the product at <a href="http://baseballtech.com">Baseball Tech</a> uses the
Zephyr sensors API in its interrupt driven form though I did have to
do some tweaking.</p>
<p>What I wanted to be able to do was...</p>
<ul>
<li>Use the hardware FIFO on many of these devices to free up time on my cpu,
the Nordic NRF52840 is quite a SoC but time is finite and much of it was
being used by other things, like bluetooth.</li>
<li>Not work with already converted values, I wanted the values that the sensor
gave directly in the native sensor format (usually 16 bit integers) primarily
because of their compact size.</li>
<li>Change the state of the device at runtime safely.</li>
</ul>
<p>Do the above without necessarily tacking on a bunch of custom
device specific functionality like I was doing.</p>
<h2 id="reflecting-on-the-first-attempt">Reflecting on the first attempt</h2>
<p>My first attempt at creating a new API that checked off the bullet list
above was based on my own experience and the opinions described in a few
issues on github.</p>
<p><a href="https://github.com/zephyrproject-rtos/zephyr/issues/1387">Issue 1387</a>
<a href="https://github.com/zephyrproject-rtos/zephyr/issues/13718">Issue 13718</a></p>
<p>The first attempt really took a lot of inspiration from Linux's IIO API.
After all, Linux often times does things right.</p>
<p>The driver was centered around a typified ringbuffer inspired by linux's
k_fifo, tailored for microcontrollers for streaming data from drivers to
applications. Along with statically defined device and channel attribute
descriptions similiar to IIO, but read and written to using a tagged type
union to represent each attributes value.</p>
<p><a href="https://github.com/bfrog/zephyr/tree/zio">ZIO Branch</a></p>
<p>The API based on IIO however really didn't solve <strong>my</strong> problems well.</p>
<p>DMA usage with a ringbuffer means I would need to have written a memory
allocator on top of it to get contiguous sections. Some form of tracking
when the end of the buffer has been skipped over. A lot more work. I'm lazy
and I wanted something working <strong>now-ish</strong>.</p>
<p>Changing the state of the device left a lot of confusion about the ringbuffer.
At what point in the ringbuffer for example was the device in state 1
rather than say state 2, where state 1 had 2 8 bit values and state 2
has 4 16 bit signed values and a timestamp? It also left me wondering
how it would ever be possible to set even a simple attribute like
sample rate when that sample rate is often times dependent on several
other configuration options. Filter options, power mode options, fifo
enabled options. So if you write to one attribute, a trigger occurs,
then write to the next attribute, was the data inbetween valid? Did
you know what format it was in, what rate the data was sampled at?</p>
<p>The attributes themselves were not necessarily simple to provide
or work with in either the driver or the application.</p>
<p>Having the driver API require a large number of attributes to be defined,
using a ringbuffer, and other decisions made on the branch turned out to
be in my opinion a dead end for the above reasoning. I'm sorry to those
that started to build on that experiment of mine in earnest. There were a few</p>
<p><a href="https://github.com/zephyrproject-rtos/zephyr/pull/16119">PR 16119</a>
<a href="https://github.com/zephyrproject-rtos/zephyr/pull/16456">PR 16456</a>
<a href="https://github.com/zephyrproject-rtos/zephyr/pull/17921">PR 17921</a></p>
<p>Maybe attributes could be salvaged, but the API wasn't really helping me
directly solve my problems. It was, it turns out, a bad API for what I was
trying to do. Hindsight is always of course clearer. I do feel like I should
have seen the issues sooner, but it took writing a driver myself and
seeing a few others starting to write drivers to realize the significant
downsides.</p>
<h2 id="second-attempt-a-work-in-progress">Second Attempt, A Work in Progress</h2>
<p>In my second attempt I focused more on what is the minimum API <strong>I</strong> need to get
the checklist ticked off. The results of that thought experiment lead me
to the following pseudo C sample snippet.</p>
<pre data-lang="c" style="background-color:#2b303b;color:#c0c5ce;" class="language-c "><code class="language-c" data-lang="c"><span>
</span><span style="color:#bf616a;">RTIO_BLOCK_MEMPOOL_ALLOCATOR</span><span>(blockalloc, </span><span style="color:#d08770;">64</span><span>, </span><span style="color:#d08770;">512</span><span>);
</span><span style="color:#bf616a;">K_FIFO_DEFINE</span><span>(myfifo);
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">struct</span><span> device *mydev = </span><span style="color:#bf616a;">device_get_binding</span><span>(SENSOR_DEV_NAME);
</span><span>
</span><span>   </span><span style="color:#65737e;">/* Using the ST H3LIS3331DL as a sample here */
</span><span>   </span><span style="color:#b48ead;">struct </span><span>mysensor_config = {
</span><span>       .</span><span style="color:#bf616a;">sample_rate </span><span>= MYSENSOR_1000HZ,
</span><span>       .</span><span style="color:#bf616a;">scale </span><span>= MYSENSOR_200G, </span><span style="color:#65737e;">/* yes this exists in the H3LIS331DL! */
</span><span>   };
</span><span>   
</span><span>   </span><span style="color:#b48ead;">struct</span><span> rtio_configuration config =  { 
</span><span>       .</span><span style="color:#bf616a;">output_config </span><span>= {
</span><span>           .</span><span style="color:#bf616a;">fifo </span><span>= myfifo, 
</span><span>           .</span><span style="color:#bf616a;">timeout </span><span>= K_FOREVER,
</span><span>           .</span><span style="color:#bf616a;">byte_size </span><span>= </span><span style="color:#d08770;">512
</span><span>       },
</span><span>       .</span><span style="color:#bf616a;">trigger_config </span><span>= {
</span><span>           .</span><span style="color:#bf616a;">trigger_source </span><span>= RTIO_TRIGGER_GPIO,
</span><span>           .</span><span style="color:#bf616a;">gpio </span><span>= {
</span><span>               .</span><span style="color:#bf616a;">device </span><span>= MYGPIO_DEV,
</span><span>               .</span><span style="color:#bf616a;">pin </span><span>= </span><span style="color:#d08770;">4</span><span>,
</span><span>           }
</span><span>       },
</span><span>      .</span><span style="color:#bf616a;">allocator </span><span>= blockalloc, 
</span><span>      .</span><span style="color:#bf616a;">driver_config </span><span>= &amp;mysensor_config
</span><span>   };
</span><span>   
</span><span>   </span><span style="color:#b48ead;">int</span><span> res = </span><span style="color:#bf616a;">rtio_configure</span><span>(mydev, &amp;config);
</span><span>   </span><span style="color:#bf616a;">_ASSERT</span><span>(res == </span><span style="color:#d08770;">0</span><span>);
</span><span>
</span><span>   </span><span style="color:#b48ead;">struct</span><span> rtio_sensor_reader reader;
</span><span>   </span><span style="color:#b48ead;">while</span><span>(</span><span style="color:#d08770;">true</span><span>) {
</span><span>       </span><span style="color:#b48ead;">struct</span><span> rtio_block *block = </span><span style="color:#bf616a;">k_fifo_get</span><span>(myfifo, K_FOREVER);
</span><span>       </span><span style="color:#b48ead;">struct</span><span> rtio_sensor_channel channels[</span><span style="color:#d08770;">4</span><span>] = {
</span><span>           </span><span style="color:#bf616a;">RTIO_SENSOR_TIMESTAMP_CHANNEL</span><span>(),
</span><span>           </span><span style="color:#bf616a;">RTIO_SENSOR_CHANNEL</span><span>(</span><span style="color:#b48ead;">float</span><span>, SENSOR_ACC_X, </span><span style="color:#d08770;">0</span><span>, SENSOR_SCALED | SENSOR_SI),
</span><span>           </span><span style="color:#bf616a;">RTIO_SENSOR_CHANNEL</span><span>(</span><span style="color:#b48ead;">float</span><span>, SENSOR_ACC_Y, </span><span style="color:#d08770;">0</span><span>, SENSOR_SCALED | SENSOR_SI),
</span><span>           </span><span style="color:#bf616a;">RTIO_SENSOR_CHANNEL</span><span>(</span><span style="color:#b48ead;">float</span><span>, SENSOR_ACC_Z, </span><span style="color:#d08770;">0</span><span>, SENSOR_SCALED | SENSOR_SI),
</span><span>       };
</span><span>       res = </span><span style="color:#bf616a;">rtio_sensor_reader</span><span>(mydev, myblock, &amp;myreader, channels, sizeof(channels));
</span><span>       </span><span style="color:#bf616a;">_ASSERT</span><span>(res == </span><span style="color:#d08770;">0</span><span>);
</span><span>       </span><span style="color:#b48ead;">while</span><span>(</span><span style="color:#bf616a;">rtio_sensor_reader_next</span><span>(&amp;myreader)) {
</span><span>           </span><span style="color:#96b5b4;">printf</span><span>(&quot;</span><span style="color:#a3be8c;">cycle: </span><span style="color:#d08770;">%d</span><span style="color:#a3be8c;">, acc (m/s^2) x,y,z: </span><span style="color:#d08770;">%f</span><span style="color:#a3be8c;">, </span><span style="color:#d08770;">%f</span><span style="color:#a3be8c;">, </span><span style="color:#d08770;">%f</span><span style="color:#96b5b4;">\n</span><span>&quot;, channels[</span><span style="color:#d08770;">0</span><span>].</span><span style="color:#bf616a;">value</span><span>.</span><span style="color:#bf616a;">u32</span><span>, channels[</span><span style="color:#d08770;">1</span><span>].</span><span style="color:#bf616a;">value</span><span>.</span><span style="color:#bf616a;">f32</span><span>, channels[</span><span style="color:#d08770;">2</span><span>].</span><span style="color:#bf616a;">value</span><span>.</span><span style="color:#bf616a;">f32</span><span>, channels[</span><span style="color:#d08770;">3</span><span>].</span><span style="color:#bf616a;">value</span><span>.</span><span style="color:#bf616a;">f32</span><span>);
</span><span>       }
</span><span>       </span><span style="color:#bf616a;">rtio_block_free</span><span>(allocator, block);
</span><span>    }
</span><span>}
</span></code></pre>
<p>Configuration is now a single call to <code>rtio_configure</code>. This includes
a way of allocating contiguous blocks, a place to put blocks that are done being
written to, and when to do so. It also includes what drives the reads, whether
its a GPIO interrupt, hardware timer, or a function all done in a forever loop
with a sleep. All of these options lead to calling<code>rtio_trigger</code>. With some
convienence sprinkled in.</p>
<p>To implement this API drivers need to implement three C functions and optionally
define a configuration struct. The first attempt had close to a dozen API calls.</p>
<p>Optionally a driver can extend the streaming API by providing a reader which
lets the application use the device almost exactly like the previous sensor API.
Some additional features this API provides are all channels can be fetched at
once, and the value may be converted to other numerical formats. The results
may be optionally scaled and converted to SI units. There are of course costs to
doing those conversions and providing that functionality.</p>
<p>The end results of this API are that</p>
<ul>
<li>The number of functions a driver must implement is reduced.</li>
<li>DMA transfers are straightforward.</li>
<li>Losing samples is less likely, so long as there's enough time to process
the data at some point and buffers are large enough.</li>
<li>Latency of data can be tuned as needed by the application with the timeout and
byte_size output config options.</li>
<li>Configuration, ordering, and verification of configurations are possible.</li>
<li>State of the device for data buffers is clear.</li>
<li>Timestamps, computed or stored, and virtual sensors could be easily provided
in the blocks, the reader is defined by the driver and channel types can be
added easily.</li>
<li>Devices have 2 functions they must implement, and a third optional function if
the device is like a sensor where you'd like to provide a way to interpret
the readings semantically.</li>
<li>Devices have a lot of room to optimize most if not all branching on reading
out data. Its very sensible that each channel would have a read function
associated with it.</li>
<li>Multiple channels of the same physical measurement are possible, the 0 in
the RTIO_SENSOR_CHANNEL macros is an added identifier describing which
channel of that type to get data for.</li>
</ul>
<p>This API is a work in progress now on several branches. Work is ongoing
and I hope to have something to show for my efforts for Zephyr 2.2!</p>
<p>Future improvements once the initial API is wrapped up.</p>
<ul>
<li>Provide fixed point formats that are DSP instruction friendly on ARM,
CMSIS DSP in particular has <code>q7_t, q15_t, and q31_t</code>. The Cortex M4
in particular has several mutiply and accumulate functions for smaller
types that CMSIS DSP takes advantage of.</li>
<li>Provide an input_configuration for writing to devices. Many devices
you can upload firmware to. This would allow both read and write
functionality. This might mean <code>rtio_trigger</code> would need to be
better thought out for reads and writes.</li>
<li>In the future the thinking is rtio_confgure will take a configuration name
defined by devicetree. This would avoid the large number of pointers being
passed from the application to the kernel preventing user mode usage.</li>
</ul>
<p>Things this API does not do that have been discussed, some of which
would be potentially useful in the future.</p>
<ul>
<li>Dynamic devices, its expected your application knows which device its
using, or atleast one of several devices. exists and could be checked
by calling <code>rtio_configure</code> for each.</li>
<li>Device attributes of any kind, in the future it <em>may</em> be sensible to
add back in some of the device attributes from the first attempt in a
more limited, read only, manner.</li>
</ul>

    </div>
</article>


        

    </div>
</body>
</html>
